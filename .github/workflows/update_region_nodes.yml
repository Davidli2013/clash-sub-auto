name: Auto Update HK SG JP Nodes

on:
  schedule:
    - cron: '0 * * * *'  # æ¯å°æ—¶æ•´ç‚¹è¿è¡Œä¸€æ¬¡
  workflow_dispatch:

jobs:
  update-region-nodes:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install pyyaml requests

      - name: Run smart update (fast if enough nodes)
        run: |
          python3 << 'EOF'
          import os
          import yaml
          import random
          import requests
          import time
          from typing import List, Dict

          # ========== æ ¸å¿ƒé…ç½® ==========
          CONFIG_FILE = "config.yaml"
          TIMEOUT = 3  # æ—§èŠ‚ç‚¹æµ‹é€Ÿè¶…æ—¶ç¼©çŸ­åˆ°3ç§’ï¼Œæ›´å¿«åˆ¤æ–­
          MIN_NODES = 30
          LATENCY_THRESHOLD = 800
          MAX_NODES_CONFIG = {"hk": 100, "sg": 30, "jp": 30}

          CF_WORKERS_API = "https://yellow-tree-130b.lijinlonghk666.workers.dev"

          REGION_CONFIG = {
              "hk": {
                  "filename": "sub_hk.yaml",
                  "keywords": ["hk", "hongkong", "é¦™æ¸¯", "HK", "HongKong", "HKT", "CN2", "æ²™ç”°", "èƒæ¹¾", "ä¸­ç¯", "ä¹é¾™"],
                  "prefix": "HK-"
              },
              "sg": {
                  "filename": "sub_sg.yaml",
                  "keywords": ["sg", "singapore", "æ–°åŠ å¡", "SG", "Singapore", "SGD", "ç‹®åŸ"],
                  "prefix": "SG-"
              },
              "jp": {
                  "filename": "sub_jp.yaml",
                  "keywords": ["jp", "japan", "æ—¥æœ¬", "JP", "Japan", "ä¸œäº¬", "å¤§é˜ª", "JPä¸œ", "JPè¥¿"],
                  "prefix": "JP-"
              }
          }

          ALLOWED_PROTOCOLS = ["trojan", "vmess", "vless", "shadowsocks", "ssr"]

          class ProxyNode:
              def __init__(self, d, prefix):
                  self.name = f"{prefix}{d.get('name', f'Node{random.randint(1000,9999)}')}"
                  self.type = d.get("type", "")
                  self.server = d.get("server", "")
                  self.port = d.get("port", 443)
                  self.password = d.get("password", "")
                  self.sni = d.get("sni", "")
                  self.skip_cert_verify = d.get("skip-cert-verify", True)
                  self.udp = d.get("udp", True)
                  self.network = d.get("network", "tcp")
                  self.uuid = d.get("uuid", "")
                  self.cipher = d.get("cipher", "")
                  self.latency = 9999.0
                  self.available = False

              def to_dict(self):
                  b = {
                      "name": self.name,
                      "type": self.type,
                      "server": self.server,
                      "port": self.port,
                      "skip-cert-verify": self.skip_cert_verify,
                      "udp": self.udp
                  }
                  if self.type == "trojan":
                      b["password"] = self.password
                      if self.sni: b["sni"] = self.sni
                  elif self.type in ["vmess", "vless"]:
                      b["uuid"] = self.uuid
                      if self.sni: b["servername"] = self.sni
                  elif self.type in ["shadowsocks", "ssr"]:
                      b["password"] = self.password
                      b["cipher"] = self.cipher
                  if self.network != "tcp":
                      b["network"] = self.network
                  return b

              def get_unique_key(self):
                  return f"{self.type}_{self.server}_{self.port}_{self.password[:8]}"

              def test(self):
                  try:
                      r = requests.post(CF_WORKERS_API, json={"server":self.server,"port":self.port}, timeout=TIMEOUT)
                      if r.status_code == 200:
                          self.latency = r.json().get("latency",9999)
                          self.available = self.latency < LATENCY_THRESHOLD
                  except:
                      self.available = False

          # è¯»å–æ—§èŠ‚ç‚¹
          def load_existing_nodes(filename):
              nodes = []
              if not os.path.exists(filename): return nodes
              try:
                  with open(filename,'r',encoding='utf-8') as f:
                      dat = yaml.safe_load(f)
                  for p in dat.get("proxies",[]):
                      if p.get("type") in ALLOWED_PROTOCOLS:
                          pref = next((v["prefix"] for k,v in REGION_CONFIG.items() if p.get("name","").startswith(v["prefix"])), "UNK-")
                          nodes.append(ProxyNode(p,pref))
              except:
                  pass
              return nodes

          # æµ‹é€Ÿä¸€æ‰¹èŠ‚ç‚¹
          def test_batch(nodes):
              start = time.time()
              for n in nodes: 
                  n.test()
                  time.sleep(0.15)  # ç¼©çŸ­é—´éš”ï¼Œæ›´å¿«æµ‹é€Ÿ
              print(f"æµ‹é€Ÿè€—æ—¶: {round(time.time()-start, 2)} ç§’")

          # å…¨ç½‘å¤§æ‹‰å–
          def fetch_all_subs():
              start = time.time()
              if not os.path.exists(CONFIG_FILE): return []
              with open(CONFIG_FILE,'r',encoding='utf-8') as f: subs = yaml.safe_load(f).get("subs",[])
              allp = []
              for u in subs:
                  try:
                      r = requests.get(u,timeout=7)
                      dat = yaml.safe_load(r.text)
                      if isinstance(dat,dict): allp += dat.get("proxies",[])
                      else: allp += dat
                  except: continue
              print(f"å…¨ç½‘æ‹‰å–è€—æ—¶: {round(time.time()-start, 2)} ç§’")
              return allp

          # ç²—ç­›åœ°åŒº
          def filter_region(proxies,kws):
              res = []
              for p in proxies:
                  if not isinstance(p,dict): continue
                  if p.get("type") not in ALLOWED_PROTOCOLS: continue
                  n = str(p.get("name","")).lower()
                  s = str(p.get("server","")).lower()
                  if any(kw.lower() in n or kw.lower() in s for kw in kws):
                      res.append(p)
              print(f"ç²—ç­›å‡º {len(res)} ä¸ªå€™é€‰èŠ‚ç‚¹")
              return res

          def build(nodes,region_name):
              avails = [n for n in nodes if n.available][:MAX_NODES_CONFIG[region_name]]
              if len(avails)<MIN_NODES:
                  avails = nodes[:MIN_NODES]
                  print(f"å¯ç”¨èŠ‚ç‚¹ä¸è¶³ï¼Œè¡¥å……ä¿åº•åˆ° {MIN_NODES} ä¸ª")
              names = [n.name for n in avails]
              return {
                  "mixed-port":7890,"allow-lan":True,"mode":"Rule","log-level":"info",
                  "external-controller":"127.0.0.1:9090",
                  "proxies":[n.to_dict() for n in avails],
                  "proxy-groups":[
                      {"name":f"{region_name} Auto","type":"url-test","proxies":names,"url":"http://www.google.com/generate_204","interval":300},
                      {"name":f"{region_name} Manual","type":"select","proxies":names+[f"{region_name} Auto","DIRECT"]}
                  ],
                  "rules":["GEOIP,CN,DIRECT",f"MATCH,{region_name} Auto"]
              }

          def main():
              total_start = time.time()
              for code,cfg in REGION_CONFIG.items():
                  print(f"\n=== å¤„ç† {code.upper()} èŠ‚ç‚¹ ===")
                  # 1. è¯»å–æ—§èŠ‚ç‚¹+å¿«é€Ÿæµ‹é€Ÿ
                  old = load_existing_nodes(cfg["filename"])
                  print(f"è¯»å–æ—§èŠ‚ç‚¹æ•°: {len(old)}")
                  test_batch(old)
                  
                  # 2. åˆ¤æ–­æ˜¯å¦å¤Ÿç”¨
                  good = [n for n in old if n.available]
                  print(f"æ—§èŠ‚ç‚¹å¯ç”¨æ•°: {len(good)} / éœ€è¦ {MIN_NODES}")

                  if len(good)>=MIN_NODES:
                      print("âœ… å¯ç”¨èŠ‚ç‚¹è¶³å¤Ÿï¼Œç›´æ¥å¤ç”¨æ—§èŠ‚ç‚¹")
                      good.sort(key=lambda x:x.latency)
                      final = good
                  else:
                      print("âŒ å¯ç”¨èŠ‚ç‚¹ä¸è¶³ï¼Œå¯åŠ¨å…¨ç½‘å¤§æœ")
                      # 3. å…¨ç½‘æ‹‰å–+ç²—ç­›+æµ‹é€Ÿ
                      allp = fetch_all_subs()
                      region_p = filter_region(allp, cfg["keywords"])
                      new_nodes = [ProxyNode(p,cfg["prefix"]) for p in region_p]
                      print(f"æ–°èŠ‚ç‚¹æ•°: {len(new_nodes)}ï¼Œå¼€å§‹æµ‹é€Ÿ...")
                      test_batch(new_nodes)
                      
                      # 4. åˆå¹¶å»é‡+æ’åº
                      pool = {n.get_unique_key():n for n in old+new_nodes}.values()
                      pool = sorted([n for n in pool if n.available], key=lambda x:x.latency)
                      final = pool[:MAX_NODES_CONFIG[code]]

                  # 5. ç”Ÿæˆé…ç½®æ–‡ä»¶
                  conf = build(final,code)
                  with open(cfg["filename"],'w',encoding='utf-8') as f:
                      yaml.dump(conf,f,default_flow_style=False,allow_unicode=True, sort_keys=False)
                  print(f"âœ… {cfg['filename']} å·²æ›´æ–°")
              
              # ç»Ÿè®¡æ€»è€—æ—¶
              total_time = round(time.time()-total_start, 2)
              print(f"\nğŸ“Š æœ¬æ¬¡è¿è¡Œæ€»è€—æ—¶: {total_time} ç§’")

          if __name__=="__main__":
              main()
          EOF

      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add sub_*.yaml
          git commit -m "Auto smart update (æ¯å°æ—¶æ£€æŸ¥) - $(date +'%Y-%m-%d %H:%M:%S')" || exit 0
          git push
