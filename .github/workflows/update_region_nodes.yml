name: Auto Update HK SG JP Nodes

on:
  schedule:
    - cron: '0 * * * *'  # æ¯å°æ—¶è¿è¡Œä¸€æ¬¡
  workflow_dispatch:      # ä¿ç•™æ‰‹åŠ¨è§¦å‘

jobs:
  update-region-nodes:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install pyyaml requests

      - name: Smart Update (æ”¾å¼€åè®®+ä½å»¶è¿Ÿç­›é€‰+å…œåº•)
        run: |
          python3 << 'EOF'
          import os
          import yaml
          import random
          import requests
          import time
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          # ========== æ ¸å¿ƒé…ç½®ï¼ˆæŒ‰ä½ çš„ä½“æ„Ÿå®šåˆ¶ï¼‰ ==========
          MIN_AVAILABLE = 30                  # ä¿åº•å¯ç”¨èŠ‚ç‚¹æ•°
          TARGET_NODES_CONFIG = {             # å„åœ°åŒºè¦æå¤Ÿçš„ä¼˜è´¨èŠ‚ç‚¹æ•°
              "hk": 100,                      # é¦™æ¸¯æå¤Ÿ100ä¸ª
              "sg": 30,                       # æ–°åŠ å¡æå¤Ÿ30ä¸ª
              "jp": 30                        # æ—¥æœ¬æå¤Ÿ30ä¸ª
          }
          BEST_LATENCY = 200                  # æœ€ä¼˜ï¼šâ‰¤200msï¼ˆèƒ½ç”¨ã€ä¸å¡ï¼‰
          ACCEPTABLE_LATENCY = 300            # å…œåº•ï¼šâ‰¤300msï¼ˆå®åœ¨æ²¡è¾™æ‰ç•™ï¼‰
          MAX_TEST_LIMIT = 800                # å•åœ°åŒºæœ€å¤šæµ‹800ä¸ªï¼ˆé˜²æ­¢æ­»å¾ªç¯ï¼‰
          TEST_INTERVAL = 0.7                 # æµ‹é€Ÿé—´éš”ï¼ˆé˜²é£æ§ï¼‰
          TEST_TIMEOUT = 3                    # æµ‹é€Ÿè¶…æ—¶æ—¶é—´

          CF_WORKERS_API = "https://yellow-tree-130b.lijinlonghk666.workers.dev"

          # åœ°åŒºå…³é”®è¯é…ç½®
          REGION_CONFIG = {
              "hk": {
                  "filename": "sub_hk.yaml",
                  "keywords": ["hk", "hongkong", "é¦™æ¸¯", "HK", "HongKong", "HKT", "CN2", "æ²™ç”°", "èƒæ¹¾"],
                  "prefix": "HK-"
              },
              "sg": {
                  "filename": "sub_sg.yaml",
                  "keywords": ["sg", "singapore", "æ–°åŠ å¡", "SG", "Singapore", "SGD", "ç‹®åŸ"],
                  "prefix": "SG-"
              },
              "jp": {
                  "filename": "sub_jp.yaml",
                  "keywords": ["jp", "japan", "æ—¥æœ¬", "JP", "Japan", "ä¸œäº¬", "å¤§é˜ª", "JPä¸œ", "JPè¥¿"],
                  "prefix": "JP-"
              }
          }

          # åˆå§‹åŒ–è¯·æ±‚ä¼šè¯ï¼ˆåŠ é‡è¯•ï¼Œå®¹é”™ï¼‰
          session = requests.Session()
          retry = Retry(connect=1, backoff_factor=0.1)
          adapter = HTTPAdapter(max_retries=retry)
          session.mount('http://', adapter)
          session.mount('https://', adapter)

          class ProxyNode:
              def __init__(self, d, prefix):
                  self.name = f"{prefix}{d.get('name', f'Node{random.randint(1000,9999)}')}"
                  self.type = d.get("type", "")
                  self.server = d.get("server", "")
                  self.port = d.get("port", 443)
                  self.password = d.get("password", "")
                  self.sni = d.get("sni", "")
                  self.skip_cert_verify = d.get("skip-cert-verify", True)
                  self.udp = d.get("udp", True)
                  self.network = d.get("network", "tcp")
                  self.uuid = d.get("uuid", "")
                  self.cipher = d.get("cipher", "")
                  self.latency = 9999.0
                  self.is_best = False   # â‰¤200msï¼ˆæœ€ä¼˜ï¼‰
                  self.is_acceptable = False  # â‰¤300msï¼ˆå…œåº•ï¼‰

              def to_dict(self):
                  """è½¬æ¢ä¸ºClashé…ç½®æ ¼å¼"""
                  b = {
                      "name": self.name,
                      "type": self.type,
                      "server": self.server,
                      "port": self.port,
                      "skip-cert-verify": self.skip_cert_verify,
                      "udp": self.udp
                  }
                  if self.type == "trojan":
                      b["password"] = self.password
                      if self.sni:
                          b["sni"] = self.sni
                  elif self.type in ["vmess", "vless"]:
                      b["uuid"] = self.uuid
                      if self.sni:
                          b["servername"] = self.sni
                  elif self.type in ["shadowsocks", "ssr"]:
                      b["password"] = self.password
                      b["cipher"] = self.cipher
                  if self.network != "tcp":
                      b["network"] = self.network
                  return b

              def get_unique_key(self):
                  """ç”Ÿæˆå”¯ä¸€æ ‡è¯†ï¼ˆå»é‡ç”¨ï¼‰"""
                  return f"{self.type}_{self.server}_{self.port}_{self.password[:8]}"

              def test_latency(self):
                  """è°ƒç”¨Cloudflare Workeræµ‹é€Ÿï¼ˆå†…åœ°è§†è§’ï¼‰"""
                  try:
                      resp = session.post(
                          CF_WORKERS_API,
                          json={"server": self.server, "port": self.port},
                          timeout=TEST_TIMEOUT,
                          headers={"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"}
                      )
                      if resp.status_code == 200:
                          self.latency = resp.json().get("latency", 9999.0)
                          self.is_best = self.latency <= BEST_LATENCY          # â‰¤200msæœ€ä¼˜
                          self.is_acceptable = self.latency <= ACCEPTABLE_LATENCY  # â‰¤300mså…œåº•
                  except Exception:
                      self.is_best = False
                      self.is_acceptable = False
                  return self.is_best or self.is_acceptable

          def load_old_nodes(filename):
              """è¯»å–ä¸Šæ¬¡ç”Ÿæˆçš„èŠ‚ç‚¹ï¼ˆæ”¾å¼€åè®®é™åˆ¶ï¼‰"""
              nodes = []
              if not os.path.exists(filename):
                  return nodes
              try:
                  with open(filename, 'r', encoding='utf-8') as f:
                      config = yaml.safe_load(f)
                  for p in config.get("proxies", []):
                      # æ”¾å¼€åè®®ï¼šåªè¦æœ‰server+portå°±è®¤ï¼Œä¸é™åˆ¶åè®®ç±»å‹
                      if isinstance(p, dict) and p.get("server") and p.get("port"):
                          # åŒ¹é…èŠ‚ç‚¹å‰ç¼€
                          prefix = ""
                          for code, cfg in REGION_CONFIG.items():
                              if p["name"].startswith(cfg["prefix"]):
                                  prefix = cfg["prefix"]
                                  break
                          nodes.append(ProxyNode(p, prefix))
              except Exception as e:
                  print(f"è¯»å–æ—§èŠ‚ç‚¹å¤±è´¥: {e}")
              return nodes

          def fast_check_old_nodes(filename, region_code):
              """å¿«é€Ÿæ£€æŸ¥æ—§èŠ‚ç‚¹ï¼Œä¼˜å…ˆæ‰¾â‰¤200msçš„ä¼˜è´¨èŠ‚ç‚¹"""
              target = TARGET_NODES_CONFIG[region_code]
              old_nodes = load_old_nodes(filename)
              best_nodes = []    # â‰¤200msï¼ˆæœ€ä¼˜ï¼‰
              accept_nodes = []  # 200-300msï¼ˆå…œåº•ï¼‰
              tested_count = 0

              print(f"å¼€å§‹æ£€æŸ¥æ—§èŠ‚ç‚¹ï¼ˆç›®æ ‡ï¼š{target}ä¸ªâ‰¤200msçš„ä¼˜è´¨èŠ‚ç‚¹ï¼‰...")
              for node in old_nodes:
                  # æå¤Ÿç›®æ ‡æ•°é‡å°±åœ
                  if len(best_nodes) >= target:
                      break
                  # æœ€å¤šæµ‹100ä¸ªæ—§èŠ‚ç‚¹ï¼ˆé¿å…æµªè´¹æ—¶é—´ï¼‰
                  if tested_count >= 100:
                      break
                  
                  node.test_latency()
                  tested_count += 1
                  if node.is_best:
                      best_nodes.append(node)
                      print(f"âœ… æœ€ä¼˜èŠ‚ç‚¹ï¼š{node.name} (å»¶è¿Ÿï¼š{node.latency}ms)")
                  elif node.is_acceptable:
                      accept_nodes.append(node)
                      print(f"âš ï¸  å…œåº•èŠ‚ç‚¹ï¼š{node.name} (å»¶è¿Ÿï¼š{node.latency}ms)")
                  time.sleep(TEST_INTERVAL)

              # ä¼˜å…ˆè¿”å›æœ€ä¼˜èŠ‚ç‚¹ï¼Œä¸è¶³åˆ™è¡¥å…œåº•èŠ‚ç‚¹
              final_old = best_nodes + accept_nodes
              print(f"æ—§èŠ‚ç‚¹æ£€æŸ¥å®Œæˆï¼šå…±æµ‹{tested_count}ä¸ªï¼Œæœ€ä¼˜{len(best_nodes)}ä¸ªï¼Œå…œåº•{len(accept_nodes)}ä¸ª")
              return final_old[:target]

          def fetch_all_sub_nodes():
              """æ‹‰å–æ‰€æœ‰è®¢é˜…æºçš„èŠ‚ç‚¹"""
              if not os.path.exists("config.yaml"):
                  print("é…ç½®æ–‡ä»¶config.yamlä¸å­˜åœ¨ï¼")
                  return []
              
              with open("config.yaml", 'r', encoding='utf-8') as f:
                  subs = yaml.safe_load(f).get("subs", [])
              
              all_nodes = []
              for idx, url in enumerate(subs):
                  try:
                      print(f"æ‹‰å–è®¢é˜…æº {idx+1}/{len(subs)}: {url}")
                      resp = session.get(url, timeout=8)
                      resp.raise_for_status()
                      data = yaml.safe_load(resp.text)
                      # å…¼å®¹Clashé…ç½®æ ¼å¼ï¼ˆdictï¼‰å’Œçº¯èŠ‚ç‚¹åˆ—è¡¨ï¼ˆlistï¼‰
                      if isinstance(data, dict):
                          all_nodes += data.get("proxies", [])
                      elif isinstance(data, list):
                          all_nodes += data
                  except Exception as e:
                      print(f"æ‹‰å–è®¢é˜…æºå¤±è´¥ {url}: {e}")
                      continue
              
              print(f"è®¢é˜…æºæ‹‰å–å®Œæˆï¼šå…±è·å–{len(all_nodes)}ä¸ªåŸå§‹èŠ‚ç‚¹")
              return all_nodes

          def filter_and_collect_good_nodes(raw_nodes, region_code):
              """ç­›é€‰åœ°åŒºèŠ‚ç‚¹ï¼ˆæ”¾å¼€åè®®ï¼‰ï¼Œä¼˜å…ˆæâ‰¤200msçš„ï¼Œä¸å¤Ÿå†è¡¥â‰¤300msçš„"""
              cfg = REGION_CONFIG[region_code]
              target = TARGET_NODES_CONFIG[region_code]
              # ç¬¬ä¸€æ­¥ï¼šç²—ç­›åœ°åŒºèŠ‚ç‚¹ï¼ˆæ”¾å¼€åè®®ï¼‰
              region_raw = []
              for p in raw_nodes:
                  # æ”¾å¼€åè®®ï¼šåªè¦æœ‰server+portå°±è®¤ï¼Œä¸é™åˆ¶åè®®ç±»å‹
                  if not isinstance(p, dict) or not p.get("server") or not p.get("port"):
                      continue
                  name = str(p.get("name", "")).lower()
                  server = str(p.get("server", "")).lower()
                  if any(kw.lower() in name or kw.lower() in server for kw in cfg["keywords"]):
                      region_raw.append(p)
              
              print(f"ç²—ç­›{region_code.upper()}èŠ‚ç‚¹ï¼š{len(region_raw)}ä¸ªå€™é€‰")
              
              # ç¬¬äºŒæ­¥ï¼šæµ‹é€Ÿï¼Œä¼˜å…ˆæâ‰¤200msçš„ï¼Œä¸å¤Ÿå†è¡¥â‰¤300msçš„
              best_nodes = []    # â‰¤200msï¼ˆæœ€ä¼˜ï¼‰
              accept_nodes = []  # 200-300msï¼ˆå…œåº•ï¼‰
              tested_count = 0
              
              for p in region_raw:
                  # æå¤Ÿç›®æ ‡æ•°é‡/æµ‹åˆ°ä¸Šé™ï¼Œå°±åœ
                  if (len(best_nodes) + len(accept_nodes)) >= target or tested_count >= MAX_TEST_LIMIT:
                      break
                  
                  node = ProxyNode(p, cfg["prefix"])
                  tested_count += 1
                  node.test_latency()
                  
                  if node.is_best:
                      best_nodes.append(node)
                      print(f"âœ… æœ€ä¼˜èŠ‚ç‚¹ [{len(best_nodes)}/{target}]: {node.name} (å»¶è¿Ÿï¼š{node.latency}ms)")
                  elif node.is_acceptable and len(best_nodes) < target:
                      accept_nodes.append(node)
                      print(f"âš ï¸  å…œåº•èŠ‚ç‚¹ [{len(best_nodes)+len(accept_nodes)}/{target}]: {node.name} (å»¶è¿Ÿï¼š{node.latency}ms)")
                  time.sleep(TEST_INTERVAL)
              
              # åˆå¹¶ï¼šæœ€ä¼˜åœ¨å‰ï¼Œå…œåº•åœ¨å
              final_new = best_nodes + accept_nodes
              print(f"{region_code.upper()}èŠ‚ç‚¹æµ‹é€Ÿå®Œæˆï¼šå…±æµ‹{tested_count}ä¸ªï¼Œæœ€ä¼˜{len(best_nodes)}ä¸ªï¼Œå…œåº•{len(accept_nodes)}ä¸ª")
              return final_new[:target]

          def build_final_config(nodes, region_code):
              """ç”Ÿæˆæœ€ç»ˆçš„Clashé…ç½®æ–‡ä»¶ï¼ˆå…œåº•åˆ°30ä¸ªï¼‰"""
              cfg = REGION_CONFIG[region_code]
              target = TARGET_NODES_CONFIG[region_code]
              
              # å»é‡ + æŒ‰å»¶è¿Ÿæ’åºï¼ˆæœ€ä¼˜çš„æ’å‰é¢ï¼‰
              unique_nodes = list({n.get_unique_key(): n for n in nodes}.values())
              unique_nodes.sort(key=lambda x: x.latency)
              
              # ä¿ç•™ç›®æ ‡æ•°é‡ï¼Œä¸è¶³åˆ™ä¿åº•åˆ°30ä¸ª
              final_nodes = unique_nodes[:target]
              if len(final_nodes) < MIN_AVAILABLE:
                  need = MIN_AVAILABLE - len(final_nodes)
                  print(f"{region_code.upper()}å¯ç”¨èŠ‚ç‚¹ä¸è¶³{MIN_AVAILABLE}ä¸ªï¼Œè¡¥å……{need}ä¸ªä¿åº•èŠ‚ç‚¹")
                  for i in range(need):
                      dummy = ProxyNode({
                          "type": "trojan",
                          "server": f"backup-{region_code}-{i}.example.com",
                          "port": 443,
                          "password": "dummy-password"
                      }, cfg["prefix"])
                      final_nodes.append(dummy)
              
              # ç»Ÿè®¡èŠ‚ç‚¹è´¨é‡
              best_count = len([n for n in final_nodes if n.is_best])
              accept_count = len([n for n in final_nodes if n.is_acceptable])
              
              # ç”Ÿæˆé…ç½®
              available_nodes = [n for n in final_nodes if n.is_best or n.is_acceptable]
              proxy_names = [n.name for n in available_nodes] if available_nodes else [final_nodes[0].name]
              
              clash_config = {
                  "mixed-port": 7890,
                  "allow-lan": True,
                  "mode": "Rule",
                  "log-level": "info",
                  "external-controller": "127.0.0.1:9090",
                  "proxies": [n.to_dict() for n in final_nodes],
                  "proxy-groups": [
                      {
                          "name": f"{region_code.upper()} Auto",
                          "type": "url-test",
                          "proxies": proxy_names,
                          "url": "http://www.google.com/generate_204",
                          "interval": 300
                      },
                      {
                          "name": f"{region_code.upper()} Manual",
                          "type": "select",
                          "proxies": proxy_names + [f"{region_code.upper()} Auto", "DIRECT"]
                      }
                  ],
                  "rules": [
                      "GEOIP,CN,DIRECT",
                      f"MATCH,{region_code.upper()} Auto"
                  ]
              }
              
              # ä¿å­˜æ–‡ä»¶
              with open(cfg["filename"], 'w', encoding='utf-8') as f:
                  yaml.dump(clash_config, f, default_flow_style=False, allow_unicode=True, sort_keys=False)
              print(f"âœ… {cfg['filename']} ç”Ÿæˆå®Œæˆï¼šä¿ç•™{len(final_nodes)}ä¸ªèŠ‚ç‚¹ï¼ˆæœ€ä¼˜{best_count}ä¸ªï¼Œå…œåº•{accept_count}ä¸ªï¼‰")

          def main():
              """ä¸»é€»è¾‘"""
              total_start = time.time()
              
              for region_code in ["hk", "sg", "jp"]:
                  print(f"\n=====================================")
                  print(f"å¼€å§‹å¤„ç† {region_code.upper()} èŠ‚ç‚¹")
                  print(f"=====================================")
                  cfg = REGION_CONFIG[region_code]
                  
                  # ç¬¬ä¸€æ­¥ï¼šæ£€æŸ¥æ—§èŠ‚ç‚¹ï¼Œå¤Ÿç›®æ ‡æ•°é‡å°±ç›´æ¥ç”¨
                  old_good = fast_check_old_nodes(cfg["filename"], region_code)
                  if len(old_good) >= TARGET_NODES_CONFIG[region_code]:
                      build_final_config(old_good, region_code)
                      continue
                  
                  # ç¬¬äºŒæ­¥ï¼šæ—§èŠ‚ç‚¹ä¸è¶³ï¼Œå…¨ç½‘ææ–°èŠ‚ç‚¹
                  print(f"âŒ æ—§èŠ‚ç‚¹ä¸è¶³ï¼Œå¼€å§‹å…¨ç½‘æ{region_code.upper()}å¯ç”¨èŠ‚ç‚¹...")
                  raw_nodes = fetch_all_sub_nodes()
                  new_good = filter_and_collect_good_nodes(raw_nodes, region_code)
                  
                  # ç¬¬ä¸‰æ­¥ï¼šåˆå¹¶æ–°æ—§ä¼˜è´¨èŠ‚ç‚¹
                  all_good = old_good + new_good
                  build_final_config(all_good, region_code)
              
              # ç»Ÿè®¡æ€»è€—æ—¶
              total_time = round(time.time() - total_start, 2)
              print(f"\nğŸ“Š æœ¬æ¬¡è¿è¡Œæ€»è€—æ—¶ï¼š{total_time} ç§’")

          if __name__ == "__main__":
              main()
          EOF

      - name: Commit and push changes (ä¿®å¤å†²çª)
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add sub_hk.yaml sub_sg.yaml sub_jp.yaml
          git commit -m "Auto update nodes (â‰¤200msæœ€ä¼˜+æ”¾å¼€åè®®) - $(date +'%Y-%m-%d %H:%M:%S')" || exit 0
          # å…ˆæ‹‰å–æœ€æ–°ä»£ç è§£å†³å†²çªï¼Œå†æ¨é€
          git pull --rebase origin main
          git push
