import yaml
import time
import schedule
import random
import requests
import socket
from ping3 import ping
from typing import List, Dict, Tuple
from dataclasses import dataclass
import logging

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('node_checker.log'),
        logging.StreamHandler()
    ]
)

# 节点数据类
@dataclass
class ProxyNode:
    name: str
    type: str  # trojan/vmess/vless/ssr
    server: str
    port: int
    password: str
    sni: str = ""
    skip_cert_verify: bool = True
    udp: bool = True
    network: str = "tcp"
    latency: float = 9999.0  # 延迟(ms)
    availability: float = 0.0  # 可用性(0-1)

    def to_dict(self) -> Dict:
        """转换为Clash配置字典"""
        base = {
            "name": self.name,
            "type": self.type,
            "server": self.server,
            "port": self.port,
            "password": self.password,
            "skip-cert-verify": self.skip_cert_verify,
            "udp": self.udp
        }
        if self.sni:
            base["sni"] = self.sni
        if self.network != "tcp":
            base["network"] = self.network
        return base

# 全局配置
CONFIG_FILE = "sub_trojan_hk.yaml"
CHECK_INTERVAL = 2  # 检测间隔(小时)
MAX_NODES = 60      # 保留最优节点数量
TEST_URLS = [
    "http://www.google.com",
    "http://www.youtube.com",
    "http://www.twitter.com"
]
TIMEOUT = 10  # 超时时间(秒)

def load_proxy_nodes(file_path: str) -> List[ProxyNode]:
    """加载配置文件中的所有节点"""
    nodes = []
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)
        
        if not config or "proxies" not in config:
            logging.error("配置文件格式错误，未找到proxies节点")
            return nodes
        
        for proxy in config["proxies"]:
            try:
                node = ProxyNode(
                    name=proxy.get("name", f"未知节点_{random.randint(1000,9999)}"),
                    type=proxy.get("type", "trojan"),
                    server=proxy.get("server", ""),
                    port=proxy.get("port", 443),
                    password=proxy.get("password", ""),
                    sni=proxy.get("sni", ""),
                    skip_cert_verify=proxy.get("skip-cert-verify", True),
                    udp=proxy.get("udp", True),
                    network=proxy.get("network", "tcp")
                )
                nodes.append(node)
            except Exception as e:
                logging.warning(f"解析节点失败: {e}")
                continue
                
    except Exception as e:
        logging.error(f"加载配置文件失败: {e}")
    
    return nodes

def test_node_connectivity(node: ProxyNode) -> Tuple[float, float]:
    """
    测试节点连通性
    返回: (延迟ms, 可用性0-1)
    """
    latency = 9999.0
    availability = 0.0
    
    try:
        # 1. 测试基础网络连通性(ping)
        ip = socket.gethostbyname(node.server)
        ping_result = ping(ip, timeout=TIMEOUT)
        if ping_result:
            latency = ping_result * 1000  # 转换为ms
        
        # 2. 测试代理可用性
        success_count = 0
        test_proxy = {
            'http': f'socks5://{ip}:{node.port}',
            'https': f'socks5://{ip}:{node.port}'
        }
        
        for test_url in TEST_URLS:
            try:
                response = requests.get(
                    test_url,
                    proxies=test_proxy,
                    timeout=TIMEOUT,
                    verify=not node.skip_cert_verify
                )
                if response.status_code == 200:
                    success_count += 1
            except:
                continue
        
        availability = success_count / len(TEST_URLS)
        
    except Exception as e:
        logging.debug(f"节点 {node.name} 测试失败: {e}")
    
    return latency, availability

def check_all_nodes(nodes: List[ProxyNode]) -> List[ProxyNode]:
    """检测所有节点并排序"""
    logging.info(f"开始检测 {len(nodes)} 个节点...")
    checked_nodes = []
    
    for i, node in enumerate(nodes):
        if i % 10 == 0:
            logging.info(f"已检测 {i}/{len(nodes)} 个节点")
        
        # 测试节点
        latency, availability = test_node_connectivity(node)
        node.latency = latency
        node.availability = availability
        
        # 只保留可用节点(可用性>0 且 延迟<500ms)
        if availability > 0 and latency < 500:
            checked_nodes.append(node)
    
    # 排序: 可用性优先，其次延迟
    checked_nodes.sort(
        key=lambda x: (-x.availability, x.latency)
    )
    
    logging.info(f"检测完成，可用节点数: {len(checked_nodes)}")
    return checked_nodes

def update_config_file(nodes: List[ProxyNode], file_path: str):
    """更新配置文件，保留最优节点"""
    # 截取最优的MAX_NODES个节点
    best_nodes = nodes[:MAX_NODES]
    
    # 构建新配置
    new_config = {
        "mixed-port": 7890,
        "allow-lan": True,
        "mode": "Rule",
        "log-level": "info",
        "external-controller": "127.0.0.1:9090",
        "proxies": [node.to_dict() for node in best_nodes],
        "proxy-groups": [
            {
                "name": "香港节点优选",
                "type": "url-test",
                "proxies": [node.name for node in best_nodes],
                "url": "http://www.google.com/generate_204",
                "interval": 300
            },
            {
                "name": "自动选择",
                "type": "select",
                "proxies": ["香港节点优选", "DIRECT"]
            }
        ],
        "rules": [
            "GEOIP,CN,DIRECT",
            "MATCH,香港节点优选"
        ]
    }
    
    # 写入文件
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            yaml.dump(
                new_config,
                f,
                default_flow_style=False,
                allow_unicode=True,
                sort_keys=False
            )
        logging.info(f"配置文件已更新，保留 {len(best_nodes)} 个最优节点")
    except Exception as e:
        logging.error(f"更新配置文件失败: {e}")

def main_task():
    """主任务：检测并更新节点"""
    # 1. 加载所有节点
    all_nodes = load_proxy_nodes(CONFIG_FILE)
    if not all_nodes:
        logging.error("未加载到任何节点")
        return
    
    # 2. 检测节点可用性
    available_nodes = check_all_nodes(all_nodes)
    
    # 3. 更新配置文件
    update_config_file(available_nodes, CONFIG_FILE)

def run_scheduler():
    """启动定时任务"""
    logging.info("节点自动检测服务启动...")
    
    # 立即执行一次
    main_task()
    
    # 定时执行（每2小时）
    schedule.every(CHECK_INTERVAL).hours.do(main_task)
    
    # 保持运行
    while True:
        schedule.run_pending()
        time.sleep(60)  # 每分钟检查一次任务

if __name__ == "__main__":
    # 支持命令行参数扩展（可选）
    import sys
    if len(sys.argv) > 1 and sys.argv[1] == "once":
        # 只执行一次检测
        main_task()
    else:
        # 启动定时任务
        run_scheduler()
